{"meta":{"title":"Statham-Li的Blog","subtitle":null,"description":null,"author":"Statham-Li","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-06-04T05:12:24.000Z","updated":"2018-07-04T02:39:14.552Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个来自辽宁的程序媛。 2015级黑龙江大学，信息管理与信息系统专业1班 爱好运动/音乐/旅行/coding…… 外表糙汉，内心细腻"}],"posts":[{"title":"原型那点事儿(1)","slug":"原型那点事儿(1)","date":"2018-07-04T02:15:33.000Z","updated":"2018-07-04T09:33:54.363Z","comments":true,"path":"2018/07/04/原型那点事儿(1)/","link":"","permalink":"http://yoursite.com/2018/07/04/原型那点事儿(1)/","excerpt":"","text":"定义：原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。obj.prototype –原型 利用原型特点和概念，可以提取共有属性eg:123456789Car.prototype.height = 1400;//统一属性放在原型中Car.prototype.lang = 4900;Car.prototype.carName = &quot;BMW&quot;;function Car(color,owner)&#123; this.owner = owner; this.color = color;&#125;var car = new Car(&apos;red&apos;,&apos;LBW&apos;);var car1 = new Car(&apos;green&apos;,&apos;xxx&apos;); 原型的增、删、改、查1.修改属性：obj.prototype.属性名 = “xxx”;2.查找属性：obj.prototype.属性名;3.增加属性：obj.prototype.新属性名 = “xxx”;4.删除属性：通过delete(不能通过对象操作原型) 查看对象的构造函数 constructorconstructor属性是系统给每个对象自带的属性，记录了这个对象的构造函数，可以手动修改 隐式属性__proto__我们之前说，一个对象创建出来，会默认创建一个空对象，但实际上，里边是有系统自带的属性的，当我们找一个对象上的属性不是该对象自身就有的时候，会通过__proto__找到该原型。也可手动修改。123var this = &#123; __proto__:Object.prototype&#125; eg1:1234567Person.prototype.name = &apos;sunny&apos;;function Person()&#123;&#125;var person = new Person();Person.prototype.name=&apos;cherry&apos;console.log(person.name)//结果为cherry,不为sunny,直接操作了属性 eg2:123456789Person.prototype.name = &apos;sunny&apos;;function person()&#123;&#125;var person = new Person();Person.prototype = &#123; name:&apos;cherry&apos;&#125;console.log(person.name)//结果为sunny，不为cherry，已经创建对象之后又修改原型 eg3:123456789Person.prototype.name = &apos;sunny&apos;;function person()&#123;&#125;Person.prototype = &#123; name:&apos;cherry&apos;&#125;var person = new Person();console.log(person.name)//结果为cherry，更改原型之后才创建对象","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"JS对象","slug":"JS对象","date":"2018-07-03T01:23:38.000Z","updated":"2018-07-04T09:34:11.763Z","comments":true,"path":"2018/07/03/JS对象/","link":"","permalink":"http://yoursite.com/2018/07/03/JS对象/","excerpt":"","text":"举例描述我心目中的对象！！(一只狗的独白，委屈巴巴)1234567891011121314151617//咳咳！敲黑板var Boyfriend = &#123; name:&quot;unknow&quot;, age:&quot;unknow&quot;, sex:&quot;male&quot;, height:&quot;180+&quot;, weight:&quot;不胖&quot;, charm:100, basketball:function()&#123; console.log(&quot;我打篮球&quot;); this.charm ++; &#125;, singing:function()&#123; console.log(&quot;我唱歌好听&quot;); this.charm ++; &#125;&#125;//气氛好像有点跑偏 当然啦，此对象非彼对象，就是举个例子，我们继续向下看 对象属性的增、删、改、查1.增加属性：直接 obj.新的属性名 = xxx2.查看属性：obj.属性名(不赋值)3.修改属性：obj.旧属性名 = xxx4.删除属性：delete obj.属性名ps:当一个变量未声明就使用时会报错，但对象的属性未声明就使用则返回undefined 对象的创建方法1.var obj = {} plainObject 对象字面量/对象直接量2.构造函数(1)系统自带构造函数 Object()1var obj = new Object(); 构造函数严格遵守大驼峰式命名方法(2)自定义 构造函数为什么能构造出对象？构造函数内部原理1.在函数体最前面隐式的加上this = {}2.执行 this.xxx = xxx;3.隐式的返回thisps:但凡new出来的对象，返回值必为对象，人为添加原始值不可以 包装类ps:原始值不可以有属性和方法数字(num)、字符串(string)、布尔值(boolean)以上三种数据类型可有两种形式123var num = new number(123);var str = new String(&apos;abcd&apos;);var bol = new Boolean(&apos;true&apos;); 上述形式会将原始值转为对象注意当对象类型的num进行运算后，会变为原始值Q1:既然原始值不能有属性和方法，那么str.length是怎么回事呢？来看一个例子eg1:123456// 包装类var num = 4;num.len = 3;// ****执行过程：new Number(4).len = 3; delete(系统发现原来的是原始值，不可以有属性，所以new一个，尽量满足需求，但num对象上本身没有len属性，则删除new出来的对象，此过程不影响原来的num)****// ****new Number(4).len -&gt;返回undefined，因为Number上并没有自带len属性，但此时的num和上一行的num不同****console.log(num.len) eg2:12345//包装类var str = &quot;1234&quot;;str.length = 2;//****执行过程：new String(&quot;1234&quot;).length = 2; delete****//new String(&quot;1234&quot;).length -&gt; 返回 4 来看一道面试题(记录自己摔的贼惨的深坑)12345678910var str = &quot;abc&quot;;str += 1;var test = typeof(str);//test == &quot;string&quot;if(test.length == 6)&#123; test.sign = &quot;typeof的返回结果可能是String&quot;; //前面不多说，都知道能走进来 //上面那句的test是个原始值啊，原始值啊，原始值啊！哪来的sign啊，当然是下面这样啦！ //new String(test).sign = &apos;xxx&apos;; delete&#125;console.log(test.sign)//new String(test).sign -&gt;打印undefined","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"网络协议(2)","slug":"网络协议-2","date":"2018-06-17T03:18:31.000Z","updated":"2018-06-17T08:42:21.619Z","comments":true,"path":"2018/06/17/网络协议-2/","link":"","permalink":"http://yoursite.com/2018/06/17/网络协议-2/","excerpt":"","text":"IP是怎么来的，又是怎么没的？1.如何配置IP地址 如果有相关的知识的积累，我们就会知道，使用命令行，我们可以手动配置IP地址，使用ipconfig或者ip addr 。那么有一个问题是，自己配置的自由度太大了，难道真的配置什么都可以吗？？？，如果设置一个完全不搭边的地址呢？比如旁边的机器是192.168.1.x,我非要配置16.158.23.6会有什么现象呢？ 答案是不会出现任何现象，只不过是包发布出去，我们举个例子，比如192.168.1.6就在你这台机器的旁边，而你试图把你机器的IP改为16.158.23.6，在这台机器上，你企图去ping192.168.1.6,你是不是认为只要将包发出去，另一台交换机马上就能收到？ 可是linux不是这样的，这里需要了解的一点是，在网络上跑的包，都是完整的，可以有下层没上层，但绝不可以有上层没下层，比如说从上至下是MAC头-&gt;IP头-&gt;TCP头-&gt;HTTP头-&gt;HTTP正文，TCP在三次握手这个活动的时候，IP层和MAC层也都会随着TCP层一起活动。因为，TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。所以，你看着它好像是有自己的IP地址，但是包发不出去，因为此时MAC层还没填。 自己的MAC地址自己知道，但目标的MAC填什么呢？是不是填192.168.1.6这台机器的MAC地址呢？当然不是的，linux首先会判断，要去的这个地址和我是一个网段的吗？只有是一个网段的时候，才会发送ARP请求获取MAC地址，如果不是一个网段的，它会试图将包发到网关。 如果你配置了网关，linux会去获取网关的MAC地址，然后将包发送出去，如果没配置网关，那么这个包是根本发送不出去的，如果把网关配置为192.168.1.6是不是就可以呢？当然不可能，因为网关要和当前的网络至少一个网卡是同一网段的，所以当你需要手动配置一台机器的网络IP时，一定要好好问问你的网络管理员，最好去网络管理员处申请，让他分配一段正确的IP，当然了，真正配置的时候不是用命令配置的，而是放在一个配置文件中，包含CIDR、子网掩码、广播地址和网关地址 2.动态主机配置协议(DHCP) 配置了IP一般是不变的，配置一个服务器端的机器还可以，但是如果客户端的机器怎么办呢？总不能随来随配吧，因此我们有了一个自动配置的协议，也称动态主机配置协议(Dynamic Host Configuration Protocol)，简称DHCP 有了这个协议，管理员只需配置一段共享的IP地址，每一台新接入的机器都通过DHCP协议来这个共享的IP地址中申请，然后自动配置好，用完以后再还回去，方便其他机器接入使用 3.了解DHCP的工作方式 当一台机器新加入一个网络的时候，一脸懵逼，只知道自己的MAC地址，先大吼一声“我来啦！”这一步，我们称为DHCP Discover。 新来的机器使用IP地址0.0.0.0发送了一个广播包，目标地址IP为255.255.255.255，广播包封装在UDP中，UDP封装在BOOTP里边，在这个广播包里边，新人喊“我是新来的(Boot request),我的MAC地址是这个，还没有IP呢，谁能给我一段IP？？？” 如果一个管理员在网络中配置了DHCP Server的话，他就相当于这些IP的管理员。他能立刻知道来了一个新人，这个时候，我们就知道MAC地址唯一的重要性了，当一台机器带着自己的MAC地址加入一个网络的时候，MAC是他惟一的身份表示，如果连这个都重复了，那也就没办法配置了 只有MAC唯一，IP管理员才知道这是一个新人，需要租给他一个IP，这个过程，我们称为DHCP Offer同时，DHCP Server为该用户保留为他提供的IP地址，从而不会为其他的DHCP客户分配此地址，但此时此刻DHCP Server仍然使用广播的地址作为目标地址，DHCP Server回复说“我分配了一段IP地址，你看看怎么样”除此之外，服务器还会发送子网掩码、网关和IP地址租用期等信息。新机器会选择一个IP，然后向网络发送一个DHCP Request广播数据包，包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等，它会告诉所有DHCP Server他将接受那一台服务器提供的IP地址，告诉其他DHCP Server谢谢你们并请求撤回他们提供的IP地址注意由于此时还未收到服务器端回应，所以此时的IP仍然是0.0.0.0，目标地址仍然是255.255.255.255 服务器收到客户机的DHCP Request之后，会返回给客户机一个ACK包，表示接受客户机选择，并将这一IP地址合法租用信息和其他租用信息放入广播包，发送给客户机，最终租约达成的时候还要广播一下，让大家都知道。","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"Jquery回顾(1)","slug":"Jquery回顾-1","date":"2018-06-11T07:08:13.000Z","updated":"2018-06-11T09:00:33.445Z","comments":true,"path":"2018/06/11/Jquery回顾-1/","link":"","permalink":"http://yoursite.com/2018/06/11/Jquery回顾-1/","excerpt":"","text":"1.循环遍历：123$(&apos;obj&apos;).each(function(index,ele)&#123; //函数体&#125;) 有趣的是js中的循环遍历方法比如forEach()的参数为① ele ② index，而jq中循环遍历方法比如each()、filter()、not()的参数为① index ② ele 刚好调换 2.添加css样式1$(&apos;obj&apos;).css(&#123;background:green;border:1px solid #000;&#125;) 或1$(&apos;obj&apos;).css(&apos;color&apos;,&apos;red&apos;) 3.选择元素(1)$()里面和css选择一样，注意对选择出的一组元素，一起处理，省略循环，这里在js中是不允许的(2)里面可以写css选择器、$、原生dom、jquery对象、null/undefined、函数function(){}、selector/content等(3)jquery特有选择规则(选择出来的是jquery对象)eg:1234$(&apos;ul&gt;li:first&apos;);$(&apos;ul&gt;li:eq(2)&apos;);$(&apos;ul&gt;li:odd/even&apos;);//odd是奇数，even是偶数//也可以写成$(&apos;ul&gt;li&apos;).first()其他相同 (4)filter筛选eg:12345$(&apos;li&apos;).filter(function(index)&#123; return index%2 == 0; &#125;).css(&apos;background&apos;,red); //筛选下标为偶数的li设置背景颜色为红色 (5)not筛选：语法与filter完全相同，但筛选规则完全相反，即筛选不满足条件的(6)has筛选:找有某项子级的父元素，不一定是直接子元素，有就行eg:1$(&apos;li&apos;).has(&apos;span&apos;).css(&apos;color&apos;,&apos;red&apos;); //这里筛选的是子级有span标签的&lt;li&gt;标签，注意是&lt;li&gt;标签 (7)find筛选：被找到的元素本身eg:1$(&apos;li&apos;).find(&apos;span&apos;).css(&apos;color&apos;,&apos;red&apos;); (8)eq筛选：选择具体下标的元素(9)is筛选：是就返回true，不是返回falseeg:1$(&apos;li&apos;).eq(4).is(&apos;.demo&apos;);//判断下标是4的li是不是class为demo的 D1:对于selector/content的解释eg:1$(&apos;span&apos;,&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;) 目的在于选择span，什么样的span呢？在div这个上下文之内的span都可以 D2:对于函数function的解释123$(function()&#123; console.log(666); &#125;) 上面的代码会立刻执行打印到控制台 D2.Q1：提出一个问题，以下代码的执行顺序是什么，为什么eg1:12345678window.onload = function()&#123; console.log(777)&#125;$(function()&#123; console.log(666); &#125;) //答案：先输出777，再输出666，难道是因为777写在上面了？我们继续看 eg2:12345678$(function()&#123; console.log(666); &#125;)window.onload = function()&#123; console.log(777)&#125;//答案：仍然先输出777，再输出666 D2.A1:新版本的jquery将$()中的函数的执行顺序调整到window.onload之后执行了，$(function(){})中调用了jq自己定义的ready方法，以下两种方法没有区别，谁写在上边谁先执行，但都在window.onload之后1234567$().ready(function()&#123; console.log(888) &#125;)$(function()&#123; console.log(666) &#125;) //先输出888，再输出666，若调换顺序，则先输出666，再输出888 4.jQuery函数写法当js和jq同时使用时需注意，只有js对象可以调用js方法，只有jq对象可以调用jq方法，交叉调用是不可以的，因此有些时候需要将js对象转变为jq对象，有时候也需要将jq对象转变为js对象 [1]jquery dom元素方法——get()方法：将jq对象转变为js对象，返回dom1$(selector).get(index) [2].取值赋值函数统一性html();text();css();attr();prop();以上函数如果传值，即为赋值，若不传值，即为取值css()取值相当于getComputed,赋值相当于dom.style.xxx，css()赋值赋一组，取值取一个(第一个 颜色会在内部转换成rgb) attr()函数主要依赖的是Element对象中getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是js原生对象属性获取和设置方式jQuery认为：attribute的checked、selected、disabled就是表示该属性初始状态的值，property的checked、selected、disabled才表示该属性实时状态的值(true/false) [3].dom操作(1)$(obj).next()下一个兄弟节点(2)$(obj).prev()上一个兄弟节点(3)$(obj).index()当前这个节点在兄弟节点中的索引(若之前返回的对象是一组数据则从第一个开始返回) ps:Jquery之所以可以链式调用，是因为每次执行都返回了相应的对象","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"网络协议(1)","slug":"网络协议-1","date":"2018-06-09T06:40:34.000Z","updated":"2018-06-10T05:33:21.559Z","comments":true,"path":"2018/06/09/网络协议-1/","link":"","permalink":"http://yoursite.com/2018/06/09/网络协议-1/","excerpt":"","text":"最近阅读了几篇不错的文章，谈一谈自己的感想，仅代表个人观点，若有不对的地方，欢迎各位指正 首先抛出一个问题，网络协议是什么？ 我们都知道，计算机很聪明，聪明到知道海量的知识，但同时它又很笨，笨到只认识0和1，我们人类要想与计算机沟通，需要一段文字把我们与计算机紧密结合起来，这段文字就是一种协议，只有通过这种协议，计算机才知道我们想让它做什么 1.协议三要素 1.语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。2.语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。3.顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值 当然了，只有一台电脑是完全不能满足我们平时的网络活动的，这时就需要一大片机器协同完成一件事，而只其中必不可缺的一项就是网络协议 2.简述网络协议 文章中用了一个购物网站下单的例子来展开，我们也就借花献佛，以此来引出我们的主题 当我们想要购买一件商品的时候，一般都会打开浏览器，输入购物地址，紧接着，浏览器就给你返回了一个绚丽多彩的页面了。那么问题来了，，，你有没有考虑过浏览器是怎样实现这一过程的呢？ 首先在浏览器中输入https://www.xxx.com ，这是一个url，浏览器会通过地址簿协议DNS或者HTTPDNS去查找，无论用哪种方式查找，最终会得到一个地址，比如我们黑龙江大学校园网125.223.1.123，这是一个IP地址，就像是我们家里的门牌号。 知道了目标地址之后，浏览器将请求打包，对于普通的网络请求，会使用HTTP协议，如果是购物，那么它涉及到你个人的私密信息，所以一般用HTTPS协议加密传输，说到这里，我们提到的DNS，HTTP，HTTPS协议都已经开始发挥了作用，他们所发挥作用的这一层是我们网络模型的第一层——应用层 经过了应用层的封装，浏览器将应用层的包发送给下一层去完成，接下来的一层叫做传输层，有两种协议，①无连接的UDP协议②面向连接的TCP协议，无连接的意思是，我只负责把上一层的包发出去，至于发送成没成功我就不管了。而面向连接的意思是，包一旦发出我会看着它，一遍没发送成功，我就继续发送，直到发送成功为止（ps:TCP协议不会引起多次请求，不管TCP发送多少次都发生在一次请求过程之内） TCP协议中有两个端口，一个是浏览器监听的端口，一个是目标服务器的端口，当传输层封装完毕后，浏览器会将包发送到下一层，即网络层。网络层的协议是IP协议，IP协议中会有两个IP地址，即浏览器所在主机的IP地址和目标服务器所在主机的IP地址。这个时候可以说已经获取了明确的地址了。 这个时候，问题又来了，我们知道门牌号了，我们怎么去嘞？？？ 这个时候操作系统要进行判断了，如果这个地址在本地，那么好，直接靠吼，一吼“谁是125.223.1.123啊？”，黑大网关回应：“我再这旮沓呢！！！”，这一吼，调用了ARP协议。如果这个地址不在本地可咋整呢？就好比我有一个朋友，家在美国，那我想从中国要去他家，我必须得通过美国海关对吧。网络也是一样，到外地去，也要通过各种关卡，这种关卡就是网关，网关所拥有的mac地址是独一无二的。这个时候操作系统就把IP包交给下一层了，也就是mac层。网关收到包之后，会根据路由表判断下一步往哪里走，每一个网关都像是唐僧西天取经路上的一个国家，每一个国家是一片局域网，出了这片局域网，就得使用IP头来进行确认下一步要往哪走，知道走到最后一个城关，在本地一吼，找到对应的mac地址，网络包过了这道城关，最终找到目标服务器。 目标服务器发现，mac地址对上了，取下mac头发送回网络层，网络层发现IP也对上号了，取下IP头，IP头中会封装TCP协议，然后传给传输层，传输层中会收到前面几层收到包的回复，这些回复也会原路返回报个平安。最终回到应用层把携带的html/css页面展现到浏览器上。","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"JS函数","slug":"JS函数","date":"2018-06-07T05:28:19.000Z","updated":"2018-07-04T09:34:39.219Z","comments":true,"path":"2018/06/07/JS函数/","link":"","permalink":"http://yoursite.com/2018/06/07/JS函数/","excerpt":"","text":"1.匿名函数：不能单独写在页面内作用：赋值，传参(匿名函数可作为参数) 2.有名函数:在function后加名字(1)可加括号自执行(2)可把名字直接放在事件位置 例： 1234function a()&#123; alert(666); &#125; document.onclick = a; 回顾：数据类型：num String boolean null undefined objecttypeof:把null归为object,增加function函数表达式和函数定义的区别：函数表达式可直接加括号自执行；123例：var a = function()&#123; alert(1); &#125;();//可执行 将匿名函数强转为函数表达式的方法：在前面加 位操作符(~ + - !)或(function(){……});函数参数：1.形参2.实参ps:实参多于形参时，多出部分相当于没有，实参少于形参时，未接收到数据的形参为undefined 关于null和undefinednull指向一个空的对象地址，因此typeof将null归为object 123456if(null==undefined)&#123; alert(1); &#125; else&#123; alert(0); &#125;//弹出1，在逻辑运算中null和undefined相等，但不全等，原因就是他们是两种不同的数据类型 undefined 不报错 声明但未定义is not defined 报错，未声明 3.不定参:arguments代表不定参数的集合12345678例：function fn()&#123; var sum=0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum+=arguments[i] &#125; alert(sum); &#125; fn(1,2,3,4,5);//弹出15 JS代码解析：第一步，解析定义，包括变量定义和函数定义，普通变量重名，后者覆盖前者。但若定义函数名和普通变量重名，函数优先级大于普通变量(var)第二步，解析执行，除定义之外的部分，包括赋值，运算等等123function A()&#123; alert(0);&#125;//从上至下，先看定义，定义了函数A，再执行，执行后弹出0 1var a = 10; //从上至下，先看定义，此时a=10,再看执行，由于alert括号内重新声明了a,所以此时a变为undefined。但若把下面的var去掉，由于少了var这一环节，所以程序报错","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-05T05:19:37.036Z","updated":"2018-06-07T04:21:10.202Z","comments":true,"path":"2018/06/05/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/05/hello-world/","excerpt":"","text":"这个博客用来记录我个人的学习和生活，欢迎各位指点交流！","categories":[],"tags":[]}]}