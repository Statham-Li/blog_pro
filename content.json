{"meta":{"title":"Statham-Li的Blog","subtitle":null,"description":null,"author":"Statham-Li","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-06-04T05:12:24.000Z","updated":"2018-11-10T11:55:00.938Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我叫李博文 一个来自辽宁的程序媛。 2015级黑龙江大学，信息管理与信息系统专业1班 希望成为一个优秀的前端工程师 爱好运动/音乐/旅行/coding…… 谁说我们的世界里只有BUG？ 诗和远方我都要！！！"}],"posts":[{"title":"你不知道的JavaScript——this和对象原型","slug":"你不知道的JavaScript——this和对象原型","date":"2019-01-29T06:47:21.000Z","updated":"2019-01-30T03:47:32.963Z","comments":true,"path":"2019/01/29/你不知道的JavaScript——this和对象原型/","link":"","permalink":"http://yoursite.com/2019/01/29/你不知道的JavaScript——this和对象原型/","excerpt":"","text":"一、误区1. this指向自身思考以下代码123456789101112131415161718192021function foo(num) &#123; console.log(&quot;foo: &quot;+ num); //记录foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i = 0; i&lt;10; i++) &#123; if (i&lt;5) &#123; foo(i); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log(foo.count); // 0 ？？？？ console.log()确实输出了4句，但是最终打印出来的还是0，显然字面意思理解的this是错误的。 真实原因是这段代码创建了一个全局变量count，它的值为NaN，具体解释后边会写 当一个函数对象内部引用自身，只使用this是不够的。一般需要一个指向函数对象的词法标识符(变量)来引用它。1234567function foo() &#123; foo.count = 4; // foo指向本身&#125;setTimeout( function ()&#123; // 匿名函数无法指向自身&#125;, 10) ps:曾经有(唯一)一种方法可以让匿名函数内部引用自身——arguments.callee，目前该方法被弃用 如果想实现我们预期的效果，我们可以使用词法作用域，将count变为一个已知对象的属性然后在函数内部使用，并打印输出(如下所示)，但这种方法回避了this的问题，我们不深究1234567891011121314151617181920212223function foo(num) &#123; console.log(&quot;foo: &quot;+ num) //记录foo被调用的次数 data.count++;&#125;var data = &#123; count: 0;&#125;var i;for (i = 0; i&lt;10; i++) &#123; if (i&lt;5) &#123; foo(i); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log(foo.count); // 4 另一种方法是使用call方法，改变this指向，我们后边会详细得说123456789101112131415161718192021function foo(num) &#123; console.log(&quot;foo: &quot;+ num); //记录foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i = 0; i&lt;10; i++) &#123; if (i&lt;5) &#123; foo.call(foo, i) &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log(foo.count); // 4 2. 它的作用域大部分人认为this指向函数作用域，确实在某种情况下它是正确的，但是在其他情况下是错误的。需要明确的是this在任何情况下都不指向函数的词法作用域。作用域“对象”([[scope]])无法通过JavaScript代码访问，它存在于JS引擎内部 this到底是什么呢？ this是在运行时绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"U dont Know","slug":"U-dont-Know","permalink":"http://yoursite.com/tags/U-dont-Know/"}]},{"title":"你不知道的JavaScript——理解作用域","slug":"你不知道的JavaScript——理解作用域","date":"2019-01-22T03:35:18.000Z","updated":"2019-01-29T03:40:25.981Z","comments":true,"path":"2019/01/22/你不知道的JavaScript——理解作用域/","link":"","permalink":"http://yoursite.com/2019/01/22/你不知道的JavaScript——理解作用域/","excerpt":"","text":"一、引言首先看一个最简单的例子1var a = 2; 开始，我们会以为这只是一个声明，但是事实并不是这样的，JS引擎认为这里有两个完全不同的声明，我们把这两个声明过程分解。 step1： var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a step2: 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量；如果不是，引擎会继续查找该变量；如果引擎找到了变量a就将2赋值给它。否则引擎会抛出异常。 二、编译器的相关术语在上述的例子中，我们用到了LHS查询，另外一种查询方式叫做RHS查询，接下来，我们说一说这两种查询方式的区别。 其实说到这里你大概能明白”L”和”R”代表的含义了，L代表Left，R代表Right；没错L和R代表一个赋值操作的左边和右边，即当变量出现在赋值操作的左侧时进行LHS查询，变量出现在赋值操作的右侧时进行RHS查询。再通俗一点说就是LHS表示找到一个变量对其进行赋值，而RHS表示的是一个赋值操作的源头 举个例子 1console.log(a) 这里对a是一个RHS引用，因为a并没有被赋值，而我们只是想取得a的值，这样才能传递给console.log(); 相比之下a = 2对a的引用则是属于LHS的，因为我们希望把=2这个操作加到a身上 引用一个书上的小测验，找出其中的LHS部分和RHS部分1234567891011121314151617function foo(a) &#123; var b = a; return a + b;&#125;var c = foo(2);/* LHS部分：①在var c = foo(2)这一步，很明显的一个赋值语句，c=属于一个LHS ②在foo函数内部一个隐式的形参 a = 属于一个LHS ③在foo函数作用域内 var b = a;又一个明显的赋值语句，b=属于一个LHS RHS部分：①在 var c = foo(2)处，我们需要知道foo(2)的值，再将其赋值给c， 因此= foo(2)是一个RHS ②在var b = a处，我们需要知道a的值是多少，因此= a是一个RHS ③④在return a + b处，我们分别需要知道a和b的值，因此这里有两个RHS*/ 三、关于LHS和RHS的异常你也许会问我们为什么要关心两种不同编译方式的异常，，，Because这两种查询的行为是不一样的 12345function foo(a) &#123; console.log(a + b); b = a;&#125;foo(2); b在RHS查询过程中是无法找到的，因为没有被声明，此时，在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常相比之下，LHS查询过程会自动创建一个变量（非严格模式下），并将其返还给引擎 ps: 严格模式下会禁止隐式或自动创建全局变量，导致LHS查询同样会报ReferenceError异常 注：关于块级作用域和函数作用域以及变量提升的问题暂不做总结 四、闭包闭包是个老生常谈的问题，在我的面试过程中几乎都被问到了，for循环是我最初学习前端时最长踩的坑了，如下所示 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i*1000)&#125; 我们开始以为会以每秒一个的速度输出数字1-5，然而，现实是，每秒一次的频率输出5次6 首先说5个6是怎么来的，由于终止条件是i不再&lt;=5，因此当i=6时第一次满足了这个条件，所以会输出i的最终值6；延迟函数的回调在循环结束时才执行，因此每次输出一个6。 Q:问题是到底为什么导致他的行为和语义所暗示的不一致？ A:我们试图假设循环中的每个迭代在运行时都会给自己”捕获”一个i的副本。但是由于作用域的工作原理，实际情况是尽管循环中的5个函数是在各个迭代中分别定义的，但是它们被封闭在一个共享的全局作用域中，因此实际上只有一个i，所有函数共享一个i的引用 我们默认你已经知道了立即执行函数的概念(IIFE)，通过声明并立即执行来创建作用域1234567for (var i = 1; i&lt;=5; i++)&#123; (function() &#123; setTimeout(function timer()&#123; console.log(i); &#125;, i*1000); &#125;)();&#125; 你觉得这样就行了？？？exo me ？？？连自己的变量都没有，还不是共用一个i，正确的打开方式是这样的1234567for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; 关于块级作用域的一点注意：for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"U dont Know","slug":"U-dont-Know","permalink":"http://yoursite.com/tags/U-dont-Know/"}]},{"title":"项目思考v1.0","slug":"项目思考v1-0","date":"2018-12-07T09:02:25.000Z","updated":"2019-01-25T06:56:34.008Z","comments":true,"path":"2018/12/07/项目思考v1-0/","link":"","permalink":"http://yoursite.com/2018/12/07/项目思考v1-0/","excerpt":"","text":"object.defineProperty和$set情景：页面1的数据接口中返回所需要使用的字段叫’form’，页面2的数据接口中返回所需要使用的字段叫’tempData’，form和tempData内容相同且为数组类型(Array)，但是组件1同时被页面1和页面2使用，此时需要做数据转化，以便数据可以在组件中正常展示 我们先来看一段代码 我们都知道引用类型的数据是不能直接赋值的，需要循环遍历，然后把数组中的每一项赋给新的数组，在这里说个前提，数组中的每一项都是基本数据类型 用红色框起来的部分是两种写法，一种是最普通的’=’赋值，还有一种是vue里边的$set，当我们使用’=’赋值的时候我们可以打印出新的对象(_newform)已经被正确赋值，但是在页面中并没有显示，而使用$set赋值的时候，新对象不仅被正确赋值，页面也会正常响应，这是为什么呢？ vue 响应式当你把一个普通的JavaScript对象传给Vue实例的data选项，Vue将遍历此对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。 这些getter/setter对用户来说是不可见的，但是在内部他们让vue追踪依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher实例对象，它会在组建渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 对象更改检测在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的。 Vue不允许在已经创建的实例上动态添加根级响应式属性，但是可以使用$set方法将相应属性添加到嵌套的对象上。 这里需要提到js原生的方法Object.defineProperty() 官方文档对该方法的解释是：Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。我们主要说一下description这个参数 数据描述符和存取描述符均具有以下可选键值 configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。数据描述符同时具有以下可选键值： value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 存取描述符同时具有以下可选键值： get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 我们直接采用’=’赋值相当于把configurable enumerable writable都赋值为true $set先上源码 vue-&gt;src-&gt;core-&gt;observer-&gt;index.js(201-231) 先进行一个判断，判断target不是undefined、null、string、number、symbol、boolean类型的数据。 1.如果target是一个数组，那么根据key值及数组长度更改数组的长度(取其中较大者)，然后直接使用splice函数修改数组，虽然vue没有监听数组变化，但是监听了数组的push,pop,shift,unshift,splice,sort,reverse函数，所以使用splice也可以达到更新dom的目的 2.如果target是一个对象，且key是对象已存在的私有属性，那么直接赋值就可以了，因为这个key必然是被监听过的 3.如果这个key目前没有存在于对象中，那么会进行赋值并监听。这里省略了ob的判断，那么ob是什么呢，vue中初始化的数据(比如data中的数据)在页面初始化的时候都会被监听，而被监听的属性都会被绑定__ob__属性，这里就是判断这个数据有没有被监听的。如果这个数据没有被监听，那么就默认你不想监听这个数据，所以直接赋值并返回 综上所述：我们使用’=’直接赋值可以读写新的对象，但是由于在已经创建的实例上无法动态添加根级响应式属性，所以会有数据改变但是vue无法监听的情况出现","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://yoursite.com/tags/项目/"}]},{"title":"项目review","slug":"项目review","date":"2018-11-10T08:55:56.000Z","updated":"2018-12-21T06:50:43.932Z","comments":true,"path":"2018/11/10/项目review/","link":"","permalink":"http://yoursite.com/2018/11/10/项目review/","excerpt":"","text":"总结一下自己的第一个企业级的项目。本次的项目是一个后台管理系统，分为两个列表，两个新建还有七个模板，目的为了创建并管理AUX规则和引导。技术栈是 vue + vue-cli3 + ElementUI，同时我们也试想如果用Bootstrap + jQuery做为技术选型，两者之间的差距是什么，接下来就说一说我自己对两种技术架构之间的理解。 一、两种技术的差别1.jQuery在2018年的7月25日，Github宣布GitHub前端已经彻底删除jQuery依赖,并全部依赖原生API。我们可以说jQuery过时了，但是过时不代表你就一定不可以再用，或者要从现有项目中清除抛弃掉。项目维护和管理本身是另一回事情，并不是完全由技术因素决定的。 jQuery的优势 1.链式调用 2.浏览器兼容性好 3.强大的选择器，可以使用css选择器、标签等获取到想操作的元素 jQuery的劣势 1.操作DOM，钩子会依赖标签，如果改变页面结构，很多依赖标签的选择器，一改起来js的部分就得跟着大改 2.不能向后兼容。每一个新版本不能兼容早期的版本。举例来说，有些新版本不再支持某些selector，新版jQuery却没有保留对它们的支持，而只是简单的将其移除。这可能会影响到开发者已经编写好的代码或插件。 3.对数据的处理有很多不便利的地方，容易导致高耦合度 2.Vue 不同于jQuery，Vue用的是MVVM的架构模式，即Model-View-ViewModel 模式。让我一句话总结MVVM就是：数据驱动DOM（无需操作DOM）。MVVM 最标志性的特性就是数据绑定，MVVM 的核心理念就是通过声明式的数据绑定来实现 View 层和其他层的分离。一张图来直观的解释一下MVVM的关系。 我们在 View 层的视图模板中声明 数据绑定、 事件绑定后，在 ViewModel 中进行业务逻辑的数据处理。事件触发后，ViewModel 中数据变更， View层自动更新。因为 MVVM 框架的引入，我们只需关注业务逻辑的数据变更，MVVM 的视图引擎会帮你搞定 View。因为数据驱动，一切变得更加简单。 MVVM的优势 1.增加视图引擎和数据存取器，视图引擎会在我们改变页面上所依赖数据的时候触发视图的更新。而数据存储器可以通过Object.defineProperty()方法来定义数据，以此来完成对数据的监听、数据变更时通知更新，是数据绑定实现的基础。 2.只需要关心数据的变化，数据驱动DOM操作更加简单 MVVM的劣势 无法兼容IE8及以下浏览器 二、基于项目对两种框架的思考以及痛点分析 ps:由于本次的项目是一个后台管理系统，因此涉及到许多新建、复制、删除、数据展示、页面跳转、表单操作等行为，这其中包含了许多数据传递及赋值的过程，我们从这个角度来分析两种架构的优劣。 1.{ { } } VS DOM操作 我们进入到列表页面的时候，在Vue的created生命周期中写了一个函数用来从后台接口中获取列表页的数据，后台给我们吐出来的是一个对象，当我们使用Vue做整体架构的时候只需要在相应的标签内用{ { } }标识我们想渲染的字段就OK了。 &lt;div&gt;{ { data.attr } }&lt;/div&gt; //data为后台返回的数据，attr为要渲染在该处的属性 但是，当我们使用jQuery时，我们的过程就繁琐了 ①获取需要操作的DOM对象，一个页面中有许多标签，为了找到唯一的那个我们需要起许多有语义又不同的名字，是不是想想就老阔疼？！ $(&#39; id/class/tagName... &#39;) ②把数据塞到元素里 $(&#39; id/class/tagName... &#39;).html(data.attr) 2.v-model优化表单 input事件绑定① 初始化页面时先在Vue实例中声明一个变量，它包含所有表单的字段及初始值，同时深拷贝一个作为备份，用于提交表单后对表单内容进行重置； ② 将上述提到的变量中的表单字段与页面中的输入框绑定好，之后当用户填完表单时，借助 v-model 的双向绑定变量的值也相应会自动整理妥当。待要上传时直接通过序号从变量中调取相应表单的数据提交即可。 其实v-model只是语法糖，双向绑定其实就等于单向绑定+UI时间监听，只不过Vue将过程采用黑箱封装起来了。好处就是方便，数据自动更新。而缺点就是无法得知是哪里更改了数据。 3.处理单选操作要用jQuery获得或者修改一组radio很麻烦，需要操作checked属性；而Vue处理radio只需通过数据，数据内容就是radio的value值，修改value值radio就会自动选择目标项。checkbox也是如此，jQuery要使用checked，而Vue只需要知道checkbox绑定的data为true或者false就可以知道checkbox是否被选中。 4.弹窗上/下一条切换弹窗的作用是用来显示点击的某条数据的详情，上/下一条数据切换其中有一个连接点就是该条数据在所有数据中的序列值 我们使用Vue，将targetIndex放到watch中监听，点击左右按钮控制targetIndex值变化并通过$emit触发父组件的方法传递上/下一条数据给弹窗，当targetIndex值变化时由于watch的存在，实时渲染 如果使用jQuery来做基础架构，会变成什么样呢？ 由于jQuery没有组件化的理念，所以我们的弹窗应该是以一个div的形式使用定位，然后通过控制display来控制显示和消失，所以这样就直接在页面间传值，不需要通过vue的$emit和$on来处理了，这看起来也许简化了操作，但是如果我们有很多页面都使用了弹窗，那么我们就需要在每一个页面中都去写这样一个div会使代码冗长，而且同样的组件不具有复用性，而且每当数据变更的时候，都需要重新去赋值很不方便 ps：由于v-if/v-show的本质也是操作DOM所以就不与jQuery作对比了，v-show是控制display:block/none 而v-if的值如果是false时，会直接把DOM砍掉，开销比v-show要大，所以这两者依情况使用 总结：jQuery完全是通过美元符号来对各种元素进行操作！根据HTML元素的id、name等属性来获取到元素并对其进行取值、赋值、修改属性能行为。 Vue的使用过程是：先绘制HTML界面，然后在需要绑定数据的地方写下v-model、v-on等这些绑定属性和方法，在显示数据内容的地方使用双大括号显示内容。然后在Vue中，el属性绑定根视图的id，data属性定义并初始化v-model、双大括号用到的数据和一些其他数据。methods属性定义在v-on中用到的和一些其他方法。更新界面修改数据实现。而修改数据通过操作界面实现。","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://yoursite.com/tags/项目/"}]},{"title":"填坑系列之git操作","slug":"填坑系列之git操作","date":"2018-10-22T09:35:49.000Z","updated":"2018-10-22T15:47:01.330Z","comments":true,"path":"2018/10/22/填坑系列之git操作/","link":"","permalink":"http://yoursite.com/2018/10/22/填坑系列之git操作/","excerpt":"","text":"前言 以前都是写些个人demo或者文章，实习之后发现，那些只是冰山一角。今天hin尴尬，提交代码的时候把develop分支冲掉了，所以下定决心好好学一下多人开发的流程，好好填坑。 一.创建本地仓库 创建一个本地仓库(文件夹),将该文件夹初始化为git仓库，即在该文件夹下点击鼠标右键(git bash here),然后使用 git init 命令，这样，初始化仓库就建好了 二.克隆代码1git clone &lt;git版本服务器地址&gt; 三.查看所有分支1git branch -a 默认有了dev和master分支，所以会看到如下三个分支 master[本地主分支] origin/master[远程主分支] origin/develop[远程开发分支] 新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步 但是origin/dev分支在本地没有任何的关联，所以我们无法在那里开发 四.进入拉取的项目文件(cd 文件名)，创建自己的开发分支123456789git checkout -b featrue-lbw origin/featrue-lbw//类似常用： // 查看分支：git branch // 创建分支：git branch &lt;name&gt; // 切换分支：git checkout &lt;name&gt; // 创建+切换分支：git checkout -b &lt;name&gt; // 合并某分支到当前分支：git merge &lt;name&gt; // 删除分支：git branch -d &lt;name&gt; 以featrue-lbw为例 ps: checkout命令加上-b参数表示创建且切换 五.进行开发 修改后看一下状态1git status 六.提交12git add .git commit -m &quot;备注&quot; 七.切换到要合并的分支(以develop分支为例)1git checkout develop 八.提交到远程1.没有冲突的情况下1git push origin featrue-lbw 2.有冲突的情况下先pull下来，解决冲突过后，先提交到本地，再提交到远程","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"填坑","slug":"填坑","permalink":"http://yoursite.com/tags/填坑/"}]},{"title":"Vuex学习(1)","slug":"Vuex学习-1","date":"2018-10-12T03:36:13.000Z","updated":"2018-10-12T06:04:06.732Z","comments":true,"path":"2018/10/12/Vuex学习-1/","link":"","permalink":"http://yoursite.com/2018/10/12/Vuex学习-1/","excerpt":"","text":"什么是Vuex 官网上以一个计数应用为例123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 该状态自管理应用包含三部分： 一、state：驱动应用的数据源；二、view:以声明方式将state映射到视图；三、actions:响应在view上的用户输入导致的状态变化单项数据流示意图：但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：Q1:多个视图依赖于同一状态。(多层嵌套组件间传参繁琐，兄弟间无法传递)Q2:来自不同视图的行为需要变更同一状态。(需要变更和同步状态的多份拷贝) 因此，我们将组件的共享状态抽取出来，以一个全局单例模式管理ps:vuex适用于大型的单页面应用，如果应用过于简单，vuex会显得很笨重","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"JS常用字符串和数组方法","slug":"JS常用字符串和数组方法","date":"2018-08-19T00:40:24.000Z","updated":"2018-08-19T09:24:36.130Z","comments":true,"path":"2018/08/19/JS常用字符串和数组方法/","link":"","permalink":"http://yoursite.com/2018/08/19/JS常用字符串和数组方法/","excerpt":"","text":"字符串一些常用方法 charAt()1str.charAt(n) =&gt;返回字符串的第 n 个字符，如果不在 0~str.length-1之间，则返回一个空字符串。123var str = &quot;javascript&quot;;str.charAt(2); //&apos;v&apos;str.charAt(12); //&apos;&apos; indexOf()1indexOf(substr,start) ＝&gt; 返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，且如果start值小于str.length则返回start值，如果大于str.length则返回str.length 12345var str = &quot;javascript&quot;;str.indexOf(&apos;s&apos;); // 4str.indexOf(&apos;s&apos;,6); // -1str.indexOf(&apos;&apos;,11); // 10str.indexOf(&apos;&apos;,8); // 8 lastIndexOf()1lastIndexOf(substr,start) = &gt; lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索1&apos;lastindex&apos;.lastIndexOf(&apos;a&apos;); // 1 substring()1str.substring(start, end) = &gt; 返回从 start 到 end（不包括）之间的字符，start、end均为 非负整数。若结束参数(end)省略，则表示从start位置一直截取到最后。 1234var str = &apos;abcdefg&apos;;str.substring(1, 4); //&quot;bcd&quot;str.substring(1); // &quot;bcdefg&quot;str.substring(-1); //&quot;abcdefg&quot; 传入负值时会视为0 slice()1str.slice(start[,end]) = &gt; 返回从 start 到 end （不包括）之间的字符，可传负值12var str = &apos;this is awesome&apos;;str.slice(4, -1); //&quot; is awesom&quot; substr()1str.slice(start,length) = &gt; 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值123var str = &quot;Just give me a reason&quot;;str.substr(5, 10); // &quot;give me a &quot;str.substr(-4, 2); // &quot;as&quot; replace()1str.replace(regexp|substr, newSubStr|function) = &gt; 替换 str 的子字符串12var str = &quot;do you love me&quot;;str.replace(&apos;love&apos;,&apos;hate&apos;); // &quot;do you hate me&quot; search()1str.search(regexp) = &gt; 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象12345var str = &apos;I love JavaScript!&apos;;str.search(/java/); // -1str.search(/Java/); // 7str.search(/java/i); // 7str.search(&apos;Java&apos;); // 7 match()1str.match(regexp) = &gt; 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象1234var str = &apos;Javascript java&apos;;str.match(/Java/); // [&quot;Java&quot;]str.match(/Java/gi); // [&quot;java&quot;, &quot;Java&quot;]str.match(/ab/g); // null split()1str.split(separator, limit) = &gt;返回一个数组，分隔符 separator 可以是一个字符串或正则表达式12345var str = &quot;Hello?World!&quot;;str.split(); // [&quot;Hello?World!&quot;]str.split(&apos;&apos;); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;?&quot;, &quot;W&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]str.split(&apos;?&apos;); // [&quot;Hello&quot;, &quot;World!&quot;]str.split(&apos;&apos;,5); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] trim()1str.trim() = &gt; 去除 str 开头和结尾处的空白字符，返回 str 的一个副本，不影响字符串本身的值123var str = &apos; abc &apos;;str.trim(); // &apos;abc&apos;console.log(str); // &apos; abc &apos; toLowerCase()1str.toLowerCase() = &gt; 将 str 转换为小写，并返回 str 的一个副本，不影响字符串本身的值123var str = &apos;JavaScript&apos;;str.toLowerCase(); // &apos;javascript&apos;console.log(str); // &apos;JavaScript&apos; toUpperCase()1str.toUpperCase() = &gt; 将 str 转换为大写，并返回 str 的一个副本，不影响字符串本身的值123var str = &apos;JavaScript&apos;;str.toUpperCase(); // &apos;JAVASCRIPT&apos;console.log(str); // &apos;JavaScript&apos; 关于number的一些属性和方法 关于num.toString()方法","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"jQuery回顾(2)","slug":"jQuery回顾-2","date":"2018-08-09T03:45:22.000Z","updated":"2018-08-09T03:48:12.456Z","comments":true,"path":"2018/08/09/jQuery回顾-2/","link":"","permalink":"http://yoursite.com/2018/08/09/jQuery回顾-2/","excerpt":"","text":"jQuery源码整体架构12345678910111213141516171819(function(global,factory)&#123; factory(global) &#125;)(typeof window !== &quot;undefined&quot; ?window : this,function(window,noGlobal)&#123;//当全局为window时在window中起作用，不为window时，传入的执行上下文起作用 //各种函数 function jQuery(selector)&#123; return new jQuery.prototype.init(); &#125; jQuery.prototype.init = function()&#123; this[0] = document.getElementsByTagName(selector)[0]; this.length = 1; &#125; jQuery.prototype.css = function()&#123; console.log(&apos;css&apos;); return this;//链式调用，必返回init对象 &#125; jQuery.prototype.init.prototype = jQuery.prototype;//******至关重要******&#125;) $()是一种函数执行的形式，$代表jQuery，与调用jQuery()一样jQuery返回jQuery.prototype.init创建的对象 init初始化元素可传参数1.$(‘’)2.string在判断string时分几种方法不一一细说了有一个match方法正则匹配两部分1参数[要匹配的,正则第一部分匹配标签&lt;&gt;,第二部分匹配id] 3.dom4.function1return root.ready !== undefined?root.ready(selector):selector(jQuery); 5.$($())1jQuery.fn = jQuery.prototype 123init = jQuery.fn.init = function(selector,context,root)&#123;//选择器，上下文，root //...&#125; $.extend对象合并(浅拷贝)eg:12345678910111213141516171819var obj1 = &#123; person1:&#123; name:&apos;dg&apos;, fun:function()&#123; console.log(&apos;hello&apos;); &#125; &#125;&#125;var obj2 = &#123; person2：&#123; name:&apos;cg&apos;, fun:function()&#123; console.log(&apos;world&apos;) &#125; &#125;&#125;$.extend(obj1,obj2);//若传一个参数，则将该参数合并到extend函数上console.log(obj1.person2.name)//cg $.fn.extend(obj1)//合并到jQuery.prototype上$.extend = $.fn.extend 四种情况1.$.extend(obj)len = 1target = $;//thisi = 0; 2.$.extend(obj1,obj2)len = 2target = obj1;i = 1;//以上两种为深拷贝 3.$.extend(true,obj1);//传true变为深拷贝len = 2target = obj1;//先等于true(i=1)后变为obj1(i=2),此时i = length所以是单纯一个对象(i–并且将target变为调用的对象$.fn)i = 2; 4.$extend(true,obj1,obj2);len = 3target = obj1;i = 2","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"前端算法之二叉树打印","slug":"前端算法之二叉树打印","date":"2018-08-06T01:58:43.000Z","updated":"2018-08-06T03:07:47.803Z","comments":true,"path":"2018/08/06/前端算法之二叉树打印/","link":"","permalink":"http://yoursite.com/2018/08/06/前端算法之二叉树打印/","excerpt":"","text":"二叉树打印按层遍历的方式对二叉树进行序列化1.用队列来进行二叉树的按层遍历，及宽度优先遍历2.除了访问节点的顺序是按层遍历之外，对结果字符串的处理，与之前的处理方式一样 二叉树按层遍历1.针对二叉树的宽度优先遍历2.宽度优先遍历常使用队列结构 eg:给定一棵二叉树的头结点head，按如下格式打印 要求打印成： 1 23 456 78 思路：使用两个变量 last和nlast记录，和一个队列queuelast表示正在打印的当前行的最右节点nlast表示下一行的最右节点令nlast为每行新元素，就能保证nlast指向当前行最右元素 个人理解：开始时，last指向头节点，头节点加入queue，弹出，然后开始遍历子节点，并弹出，子节点遍历完，检验last是否和爹一样，若不一样则继续遍历下一个爹的子节点，直到找到和last指向相同的爹，此时，last指向该爹的小儿子（最后找到的子节点），这时，上一轮的儿子，变为下一轮遍历的爹，继续遍历，直到全部打印完 二叉树的序列化和反序列化1.二叉树-&gt;字符串(序列化)2.字符串-&gt;二叉树(反序列化) 序列化方式1.根据先序遍历序列化2.根据中序遍历序列化3.根据后序遍历序列化4.按层序列化 思路:(先序为例)1.假设序列化结果为str，初始时str为空字符串2.先序遍历二叉树时如果遇到空节点，在str末尾加上”#!”3.如果遇到不为空的节点，假设节点值为3，就在str末尾加上”3!”ps：如果不用特殊符号表示值的结束，则这两棵树的序列化结果为：123### 会产生歧义 反序列化：与序列化相反ps:1.选择什么样的遍历方式序列化，就用什么方式反序列化2.一棵树序列化结果是唯一的，唯一的结果生成的二叉树也是唯一的","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"ES6知识点梳理(6)","slug":"ES6知识点梳理-6","date":"2018-07-20T02:04:55.000Z","updated":"2018-07-22T15:47:26.737Z","comments":true,"path":"2018/07/20/ES6知识点梳理-6/","link":"","permalink":"http://yoursite.com/2018/07/20/ES6知识点梳理-6/","excerpt":"","text":"promise对象特点：1.对象的状态不受外界影响。Promise对象代表一个异步操作，有3种状态：Pending(进行中) Resolved(已完成又称fulfilled) rejected(已失败)，只有异步操作结果可以决定当前的状态，任何操作都无法改变这个状态2.只有两种可能：从Pending到resolved或从pending到rejected，只要其中一个发生，状态就会凝固，不会再变。就算已经改变，再对Promise对象添加回调函数，也会立即得到这个结果。与事件(event)不同，事件如果错过，再去监听找不到结果缺点1.无法取消，一旦新建就立即执行，无法中途取消2.若不设置回调函数，Promise内部抛出错误不会反映到外部 用法Promise对象是一个构造函数，用来生成Promise实例eg:12345678var promise = new Promise(function(selove,reject)&#123; //...some code if(/* 异步操作成功 */)&#123; resolve(value); &#125;else&#123; reject(error); &#125; &#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，这是两个函数，由js引擎提供。resolve函数在异步操作成功时调用，并将异步操作的结果作为参数传递出去，reject函数在失败时调用，并将异步操作报出的错误作为参数传递出去吧Promise实例生成后，可以用then方法分别指定resolve状态和reject状态的回调函数eg:12345promise.then(function(value)&#123; //success &#125;,function(value)&#123; //failure&#125;) then方法可以接受两个回调函数作为参数，第一个回调函数是promise对象的状态变为resolve时使用的，第二个（可选）是promise对象状态变为reject时调用的。两个函数都接受promise对象传出来的值作为参数。如果调用resolve函数和reject函数时带有参数，那么这些参数会被传递给回调函数，reject函数的参数通常是error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值外，还可能是另外一个Promise实例，表示异步操作的结果很有可能是一个值，也有可能是另一个一步操作eg:12345678var p1 = new promise(function(resolve,reject)&#123; //... &#125;);var p2 = new Promise(function(resolve,reject)&#123; //... resolve(p1); &#125;) //p1的状态决定了p2的状态 Promise.prototype.then()Promise实例具有then方法。也就是，then方法是定义在原型对象Promise.prototype上的。then方法返回的是一个新的Promise实例。因此可以采用链式写法。 Promise.prototype.catch() (推荐catch)Promise.prototype.catch方法是.then(null,rejection)的别名，用于指定发生错误时的回调函数。eg:1234567getJSON(&quot;/posts.json&quot;).then(function(posts)&#123; //... &#125;).catch(function(error)&#123; console.log(&apos;发生错误&apos;,error); &#125;); //getJSON()方法假设为一个返回promise对象的函数，如果该对象状态变为resolved，则会调用then方法指定的回调函数。如果异步抛错，状态变为reject ps:promise对象的错误有冒泡性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个catch捕获。如果不使用catch而是使用then，该错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出，错误会冒泡到最外层，成了未捕获的错误，catch方法返回的还是Promise对象，因此后边还可以接着调用then方法 promise.all()promise.all方法用于将多个Promise实例包装成一个新的promise实例eg:1var p = Promise.all([p1,p2,p3]) promise.all方法接受一个数组作为参数，p1，p2，p3都是promise对象的实例，如果不是，就会先调用下面讲到的promise.resolve方法，将参数转为Promise实例。(Promise.all方法的参数不一定是数组，但必须有itertor接口，且返回的每个成员都是promise实例) 1.有p1,p2,p3状态都变成fulfilled，p的状态才会变成fulfilled，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数。2.p1,p2,p3但凡有一个被reject，p的状态就变为rejected，此时第一个被rejected的实例返回值会传递给p的回调函数 promise.race()eg:1var p = Promise.race([p1,p2,p3]); 与promise.all方法的相同点是，将多个Promise实例包装成一个新的Promise实例，不同点是，只要p1,p2,p3中有一个改变，p的状态就跟着改变，率先改变的Promise实例的返回值，就传递给p的回调函数 promise.resolve()将现有对象转为Promise对象，Promise.resolve方法就起到这个作用eg:1var jsPromise = Promimse.resolve($.ajax(&apos;/whatever.json&apos;)) 上面的代码将jQuery对象生成的deferred对象转为新的promise对象","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"前端算法之二叉树(1)","slug":"前端算法之二叉树-1","date":"2018-07-18T06:52:35.000Z","updated":"2018-07-19T02:35:22.041Z","comments":true,"path":"2018/07/18/前端算法之二叉树-1/","link":"","permalink":"http://yoursite.com/2018/07/18/前端算法之二叉树-1/","excerpt":"","text":"二叉树1.平衡二叉树：任意一个节点其左节点的层数与右节点的层数相差不超过一2.完全二叉树：除了叶子节点 之外每个节点都有两个子节点3.满二叉树：（1） 所有层都是满的（2） 要么没有子节点，有子节点就必须要有两个 eg:平衡二叉树eg:完全二叉树eg:满二叉树 二叉树的描述方式1.前序：首先访问根节点 （ 根-&gt; 左 -&gt; 右）2.中序： 中间访问根节点（ 左-&gt; 根 -&gt; 右）3.后序： 最后访问根节点 ( 左-&gt; 右 -&gt; 根） 代码构造二叉树1.菜鸟写法12345678910111213141516171819202122function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right; &#125; function setTree() &#123; var root = new Node(1, null, null); var node1 = new Node(2, null, null); var node2 = new Node(3, null, null); var node3 = new Node(4, null, null); var node4 = new Node(5, null, null); var node5 = new Node(6, null, null); var node6 = new Node(7, null, null); root.left = node1; root.right = node2; node1.left = node3; node1.right = node4; node2.left = node5; node2.right = node6; return root; &#125; var tree = setTree(); 这样写确实通俗易懂，但是实现起来所占空间实在是不敢恭维，所以我们是不是有什么办法，用更少的空间存储二叉树呢 2.进阶写法123456789function pre(node) &#123; //传入一棵树 if (node == null) &#123; return ; &#125; pre(node.left); // 使用递归 pre(node.left)-&gt;打印node.left的data值 pre(node.right); // 现在所看到的这个程序执行 左-&gt;右-&gt;根 的顺序，后序遍历 console.log(node.data); &#125;pre(tree); 根据前序/中序遍历、后序/中序遍历确定一棵二叉树为了方便，我们先把三种遍历方式的顺序写出来123var pre = [1,2,4,5,3,6]; //前序var mid = [4,2,5,1,3,6]; //中序var aft = [4,5,2,6,3,1]; //后序 1.前序/中序遍历1234567891011121314151617181920212223242526272829function perMid(pre, mid) &#123; if(pre.length == 0 || mid.length == 0) &#123; return null; &#125; if (pre.length != mid.length) &#123; throw Error(&apos;参数不正确&apos;) &#125; // 根节点数据 var rootData = pre[0]; // 根节点在中序遍历中的位置 var midRootIndex = mid.indexOf(rootData); // 左子树中序遍历 var leftMid = mid.slice(0, midRootIndex); //截取中序数组根节点之前的为左子树 // 右子树中序遍历 var rightMid = mid.slice(midRootIndex + 1); //截取中序数组根节点之后的为右子树 // 左子树前序遍历 var leftPre = pre.slice(1, leftMid.length + 1); /*截取前序数组：第一项是根节点所以从第二项开始截取，截取长度为左子树节点个数 所以截取到leftMid.length + 1的位置(slice不含下标为leftMid.length + 1)*/ // 右子树前序遍历 var rightPre = pre.slice(leftMid.length + 1); //从leftMid.length + 1的位置开始截取，到最后 // 左子树还原 var left = perMid(leftPre, leftMid); //递归，传入左子树的前、中序遍历 // 右子树还原 var right = perMid(rightPre, rightMid); //同上 // 最终二叉树 var node = new Node(pre[0], left, right); return node; &#125; 2.后序/中序遍历12345678910111213141516171819202122232425262728function afterMid(aft, mid) &#123; if(aft.length == 0 || mid.length == 0) &#123; return null; &#125; if (aft.length != mid.length) &#123; throw Error(&apos;参数不正确&apos;) &#125; // 根节点数据 var rootData = aft[aft.length - 1]; // 根节点在中序遍历中的位置 var midRootIndex = mid.indexOf(rootData); // 左子树中序遍历 var leftMid = mid.slice(0, midRootIndex); // 右子树中序遍历 var rightMid = mid.slice(midRootIndex + 1); // 左子树后序遍历 var leftAft = aft.slice(0, leftMid.length); // 右子树后序遍历 var rightaft = aft.slice(leftMid.length, aft.length - 1); // 左子树还原 var left = afterMid(leftAft, leftMid); // 右子树还原 var right = afterMid(rightaft, rightMid); // 最终二叉树 var node = new Node(aft[aft.length - 1], left, right); return node; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"ES6知识点梳理(5)","slug":"ES6知识点梳理-5","date":"2018-07-18T01:22:46.000Z","updated":"2018-07-19T09:03:51.894Z","comments":true,"path":"2018/07/18/ES6知识点梳理-5/","link":"","permalink":"http://yoursite.com/2018/07/18/ES6知识点梳理-5/","excerpt":"","text":"GeneratorGenerator是ES6提供的一种异步编程解决方案，它是一种状态机封装了多个内部对象，执行Generator函数会返回一个遍历器对象 形式上，Generator函数就是普通函数，但有两个特性1.function命令与函数名之间有一个*2.函数体内部使用yield语句定义不同的内部状态eg:123456function* helloGenerator()&#123; yield &apos;hello&apos;; yield &apos;Generator&apos;; return &apos;ending&apos;;&#125;var hg = helloGenerator(); 该函数有三个状态：hello、Generator和return语句(结束执行) ps:Generator函数的调用与普通函数相同，但调用后Generator函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，即iterator对象，接下来就要使用next方法使得指针移向下一个状态。即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一条yield语句(或return语句)为止。换言之，Generator函数是分段执行的，yield语句是暂停执行标记，而next方法可以恢复执行 yield语句使用注意事项1.普通函数中使用yield语句报错2.yield语句若要用在一个表达式中，必须放在圆括号里3.yield语句用作函数参数或用于赋值表达式的右边，可以不加括号根据语法规范，yield 的作用是代理 yield 表达式，将需要函数本身产生（yield）的值委托出去。yield 后面跟一个生成器函数、或其他可迭代的对象（如一个数组、字符串、arguments对象）。yield 表达式的返回值，就是其后面可迭代对象迭代完毕时的返回值。*eg:12345678910111213141516var arr = [1,[[2,3],4],[5,6]];var flat = function* (a)&#123; var length = a.length; for(var i = 0;i&lt;length;i++)&#123; var item = a[i]; if(typeof item !== &apos;number&apos;)&#123; yield* flat(item); &#125;else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr))&#123; console.log(f);&#125;// 1,2,3,4,5,6 next方法的参数yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当成上一条yield语句的返回值eg:12345678910function* foo(x)&#123; var y = 2*(yield(x+1)); var z = yield(y/3); return (x+y+z);&#125;var b = foo(5);b.next() // &#123;value:6,done:false&#125; y=x+1=6b.next(12) // &#123;value:8,done:false&#125; y = 2*12 z = 24/3=8b.next(13) // &#123;value:42,done:true&#125; z = 13 y = 24 x = 5 x+y+z = 42 for…of循环for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法(ps:一旦next方法的done属性为true则循环终止，且不包含该返回对象，比如不包含return出的值) yield* 语句如果在Generator函数中调用另一个Generator函数，默认是没效果的，默认返回一个遍历器对象，若用yield*返回遍历对象的内部值eg:12345678910111213function* foo()&#123; yield &apos;a&apos;; yield &apos;b&apos;;&#125;function* bar()&#123; yield &apos;x&apos;; foo(); yield &apos;y&apos;;&#125;for(let v of bar())&#123; console.log(v); //&quot;x&quot; , &quot;y&quot;&#125; 这时，使用yield*语句(相当于在Generator函数内部部署一个for..of循环)1234567891011121314function* bar()&#123; yield &apos;x&apos;; yield* foo(); yield &apos;y&apos;;&#125;//等价于function* bar()&#123; yield &apos;x&apos;; yield &apos;a&apos;; yield &apos;b&apos;; yield &apos;y&apos;;&#125; 作为对象属性的Generator函数若函数的属性是Generator函数，可简写成如下形式12345let obj = &#123; * myGeneratorMethod()&#123; ... &#125;&#125; 完整形式12345let obj = &#123; myGeneratorMethod: function* ()&#123; //... &#125;&#125; Generator函数的thisGenerator函数总是返回一个遍历器（不返回this），ES6规定这个遍历器是Generator函数的实例，它是继承了Generator函数的prototype对象上的方法用Generator函数作为构造函数时，直接new无法生成实例，因为返回一个内部指针正确使用方法是：生成一个空对象，使用bind方法绑定Generator函数内部的this，这样构造函数调用以后，这个空对象就是Generator函数的实例对象了1234567function* ()&#123; yield this.x = 2; yield this.y = 3;&#125;var obj = &#123;&#125;var f = F.bind(obj)();//首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"ES6知识点梳理(4)","slug":"ES6知识点梳理-4","date":"2018-07-17T02:16:55.000Z","updated":"2018-07-17T08:39:06.534Z","comments":true,"path":"2018/07/17/ES6知识点梳理-4/","link":"","permalink":"http://yoursite.com/2018/07/17/ES6知识点梳理-4/","excerpt":"","text":"Iterator和for…of循环Iterator：是一种机制，也是一种接口，任何数据结构只要部署了Iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)Iterator的作用：1.为各种数据提供一个统一的，简便的访问接口2.使得数据结构的成员能够按某种次序排序3.for…of循环，Iterator接口主要供for…of消费 Iterator的遍历过程：1.创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上就是一个指针对象2.第一次调用指针对象的next方法，指针就指向数据结构的第一个成员，每次调用向后指一个3.不断调用指针对象的next方法，直到它指向数据结构的结束位置ps:每一次调用next都返回当前成员的信息，包含value和done两个属性的对象，value是当前成员的值，done是布尔值，表示遍历是否结束 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，即一个数据只要有symbol.iterator属性，就可认为它是“可遍历的”在ES6中，有3类数据结构原生具备Iterator接口：数组、某些类似数组的对象，set，map(普通对象不能直接部署symbol.iterator接口)eg1:12345678910let iterable = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3, [symbol.iterator]:Array.prototype[symbol.iterator]&#125;;for(let item of iterable)&#123; console.log(item); // &apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125; eg2:12345678910let iterable = &#123; a: &apos;a&apos;, b: &apos;b&apos;, c: &apos;c&apos;, length: 3, [symbol.iterator]:Array.prototype[symbol.iterator]&#125;;for(let item of iterable)&#123; console.log(item); // undefined,undefined,undefined&#125; 如果symbol.iterator方法对应的不是遍历器生成函数(即会返回一个遍历器对象)，解释引擎将报错 调用Iterator接口的场合1.解构赋值对数组和Set结构进行解构赋值是，会默认调用Symbol.iterator方法eg:123456let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);let [x,y] = set;// x = &apos;a&apos;;y = &apos;b&apos;let [first,...rest] = set;//first = &apos;a&apos;;rest = [&apos;b&apos;,&apos;c&apos;]; 2.扩展运算符扩展运算符也会调用默认的Iterator接口eg1:12var str = &apos;hello&apos;;[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;] 3.yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组为参数的场合其实都调用了遍历器接口eg:12345for...ofArray.from()Map()、Set()、WeakMap()、WeakSet()Promise.all()Promise.race() ps:遍历器还可以具有return(）和throw()方法，可手动部署。 如果for…of循环提前退出，就会调用return方法ps:javascript原有的for…in循环只能获取键名不能获取键值，而for…of可以获取键值（for…of可通过entries()和keys()方法实现获取数组索引）","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"ES6知识点梳理(3)","slug":"ES6知识点梳理-3","date":"2018-07-16T09:42:24.000Z","updated":"2018-07-17T02:09:41.950Z","comments":true,"path":"2018/07/16/ES6知识点梳理-3/","link":"","permalink":"http://yoursite.com/2018/07/16/ES6知识点梳理-3/","excerpt":"","text":"mapObject提供了“字符串-值”的对应，而map提供了“值-值”的对应，是一种更完善的Hash结构实现。 map可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组eg:123456var map = new map([[&quot;name&quot;,&quot;张三&quot;]，[&quot;title&quot;,&quot;Author&quot;]]);map.size // 2map.has(&quot;name&quot;); // truemap.get(&quot;name&quot;); // 张三//此代码在新建map实例时就指定了两个键(name和title) 对同一个键多次赋值，后面的值将覆盖前面的值，若是读取一个未知的值，返回undefined，当然了，只有对同一个对象的引用，map才将其视为同一个键eg:123var map = new map();map.set([&apos;a&apos;],555);map.get([&apos;a&apos;]) // undefined 表面上针对同一个键，实际上是两个值，内存地址不同 如果map的键是一个简单类型的值(数字，字符串，布尔)，则只要求两个值严格相等，map就将其视为一个键，包括0和-0。虽然NaN不严格等于自身，但map将其视为一个值 实例的属性和操作方法size属性：返回map结构的成员总数 1.set(key,value)方法：设置key所在键值，然后返回整个map结构，如果key已经有值，则键值会被更新，否则新生成该键，返回map本身，因此可以使用链式调用2.get(key)方法：读取key对应的键值，若找不到则返回undefined3.has(key)方法返回一个布尔值，表示某个键是否在map数据结构中4.delete(key)方法：删除指定键，成功返回true，反之返回false5.clear()方法：清除所有成员，没有返回值 遍历方法map提供3个遍历器生成函数和1个遍历方法 keys():返回一个键名的遍历器values():返回一个键值的遍历器entries():返回所有成员的遍历器forEach():遍历map所有成员，与数组的forEach相似，forEach的第一个参数是函数，还可以传第二个参数，用于绑定this 与其他数据类型的转化1.将map转为数组结构 方法：结合使用扩展运算符(…) 结合数组的map方法、filter方法，可以实现map的遍历和过滤(map本身没有map和filter方法) 2.数组转为map 方法：将数组传入map构造函数 3.map转为对象 如果map所有键都是字符串，则可以转为对象 WeakMapWeakMap结构与map结构类似，唯一的区别是它只接受对象作为键名(对照WeakSet)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"ES6知识点梳理(2)","slug":"ES6知识点梳理-2","date":"2018-07-16T02:10:01.000Z","updated":"2018-07-25T08:38:35.418Z","comments":true,"path":"2018/07/16/ES6知识点梳理-2/","link":"","permalink":"http://yoursite.com/2018/07/16/ES6知识点梳理-2/","excerpt":"","text":"setset是ES6提供的新的数据结构，它类似于数组，但成员都是唯一的，没有重复的值。Set本身就是一个构造函数，用来生成set数据结构，向set加入值时不会发生类型转换，所以”5”和5是两种不同的值。 set的操作方法add(value)：添加某个值，返回set结构本身delete(value):删除某个值，返回一个布尔值，表示删除是否成功has(value):返回一个布尔值，表示参数是否为set的成员clear():清除所有成员，没有返回值 Array.from方法可以将set结构转为数组eg:12var items = new Set([1,2,3,4,5]);var array = Array.from(items); 由于set的成员都是唯一的，没有重复值，所以，就有了一种新的数组去重的方法eg:1234function dedupe(array)&#123; return Array.from(new Set(array));&#125;dedupe([1,1,2,3])//[1,2,3] 遍历操作 Set结构有4个遍历方法，可用于遍历成员 keys():返回一个键名的遍历器 values():返回一个键值的遍历器 entries():返回一个键值对的遍历器 forEach():使用回调函数遍历每个成员 ps:keys/values/entries方法都返回遍历器对象，由于Set结构没有键名，只有键值（键名键值相同），所以keys和values方法的行为完全一致 由于扩展运算符(…)内部使用for…of循环（去重），所以也可以用于Set结构eg:123let set = new Set([&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;]);let arr = [...set];// [&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;] 因此有了另一种数组去重方法123let arr = [3,5,2,2,5,5];let unique = [...new Set(arr)];//[3,5,2] 除此之外，数组的map和filter方法也可用于Set了。返回set结构 Set结构的实例的forEach方法用于对每个成员执行某种操作，没有返回值ps:forEach是一个处理函数，该函数的参数依次为键值，键名，集合本身。forEach方法还可以有第二个参数，表示绑定的this对象 不能直接在遍历中改变原来的set结构，若想改变只有两种方法1.使用新的set结构映射出一个新的结构，然后赋值给原来的set结构2.利用Array.from方法eg1:123let set = new Set([1,2,3]);set = new Set([...set].map(val=&gt;val*2));//set 的值是2,4,6 eg2:123let set = new Set([1,2,3]);set = new Set(Arr.from(set,val =&gt; val*2))//set 的值是2,4,6 WeakSet与Set相似，是不重复的值的集合，但是，与Set有两个区别1.WeakSet的成员只能是对象，不能是其他类型2.WeakSet中的对象都是弱引用，如果其他对象都不在引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet中，因此WeakSet不可遍历(没有size属性)ps:WeakSet构造方式与Set类似，不多介绍了 3个方法WeakSet.prototype.add(value):添加新成员WeakSet.prototype.delete(value):删除指定成员WeakSet.prototype.has(value):返回布尔值，表示某个值是否在WeakSet实例中","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"ES6知识点梳理(1)","slug":"ES6知识点梳理-1","date":"2018-07-13T01:57:53.000Z","updated":"2018-07-15T15:50:35.216Z","comments":true,"path":"2018/07/13/ES6知识点梳理-1/","link":"","permalink":"http://yoursite.com/2018/07/13/ES6知识点梳理-1/","excerpt":"","text":"let const 和 var ES5中的变量声明方式有var和function，一个声明变量，一个声明函数。在ES6中新增加了let和const方法 let命令 1.let命令的用法类似于var，但是所声明的变量只在let命令所在代码块中起作用 2.let不想var那样会发生”变量提升”，因此变量一定要在声明后使用，否则报错 3.let不允许在相同作用域内重复声明同一个变量ps:ES6明确规定如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成了封闭作用域。只要在声明之前使用这些变量就会报错(暂时性死区) 块级作用域 为什么要有块级作用域？ 1.内层变量覆盖外层变量造成全局污染12345678var tmp = new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp = &quot;hello world&quot; &#125;&#125;f()//undefined 变量提升导致内层tmp变量覆盖了外层tmp变量 ES6块级作用域中，外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量 const命令 const命令用来声明常量，一旦声明，其值不能改变，因此const一旦声明，就必须立即初始化，不能留到以后赋值，与let一样，const也不可重复声明变量，对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不能保证该地址的数据不变，所以将一个对象声明为常量必须非常小心 ps:let命令、const命令、class命令声明的全局变量不属于全局对象的属性eg:12345var a = 1;window.a // 1let b = 1;window.b // undefined//a由var声明，所以是全局对象的属性，而b由let声明，所以不是全局变量的属性，返回undefined","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"}]},{"title":"原型那点事儿(2)","slug":"原型那点事儿-2","date":"2018-07-04T09:46:57.000Z","updated":"2018-07-05T08:12:39.254Z","comments":true,"path":"2018/07/04/原型那点事儿-2/","link":"","permalink":"http://yoursite.com/2018/07/04/原型那点事儿-2/","excerpt":"","text":"我们知道对象有原型，但细心一点的童鞋会发现，原型还有__proto__属性，这是为啥呢，哈，我们来看看原型链eg:123456789101112131415Grandpa.prototype.lastName = &quot;James&quot;;function Grandpa()&#123;&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = &apos;LeBron&apos;&#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobby = &quot;smoke&quot;;&#125;var son = new Son(); 我们打印son.lastName 会显示”James”，当然了，Grandpa.prototype绝不是终点，当我们打印Grandpa.prototype.__proto__时，会发现它指向Object.prototype，Object.prototype是原型链顶层 Object.create(原型)创建对象eg:12345var obj = &#123; name: &quot;sunny&quot;, age: 123&#125;;var obj1 = Object.create(obj);//将原型设为obj，因此obj1就有了name和age属性 绝大多数对象的最终都会继承自Object.prototype (√)原因：我们发现()中可以填null，当填入null时，该对象没有原型，__proto__这个属性，如果系统给了，你可以改，如果系统没给，手动添加无效 关于toString()这个方法我们知道不同类型的变量调用toString()这个方法的返回值是不同的1.num 2.boolean 3.object 以num为例，还原整个过程123456var num = 123;//num.toString(); --&gt; new Number(num).toString();此时是在Number原型上找//Number.prototype.toString = function()&#123;...&#125; 但是吧Number原型上并没有所以就顺着原型链继续找//Number.prototype.__proto__ = Object.prototype; 此时Object原型上有toString方法了//但是我们看到了，Obj和num调用toString()方法返回的东西不同，这就说明，Number重写了Object原型上的toString()方法num.toString();//&quot;123&quot; ps:有一点需要注意的是，document.write()这个方法在调用时，会默认调用toString()方法，因此如果写成如下形式，会报错，因为没有原型的obj没有toString()方法12var obj = Object.creat(null);document.write(obj);//()中实际上是obj.toString()","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"原型那点事儿(1)","slug":"原型那点事儿-1","date":"2018-07-04T02:15:33.000Z","updated":"2018-07-04T09:33:54.363Z","comments":true,"path":"2018/07/04/原型那点事儿-1/","link":"","permalink":"http://yoursite.com/2018/07/04/原型那点事儿-1/","excerpt":"","text":"定义：原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。obj.prototype –原型 利用原型特点和概念，可以提取共有属性eg:123456789Car.prototype.height = 1400;//统一属性放在原型中Car.prototype.lang = 4900;Car.prototype.carName = &quot;BMW&quot;;function Car(color,owner)&#123; this.owner = owner; this.color = color;&#125;var car = new Car(&apos;red&apos;,&apos;LBW&apos;);var car1 = new Car(&apos;green&apos;,&apos;xxx&apos;); 原型的增、删、改、查1.修改属性：obj.prototype.属性名 = “xxx”;2.查找属性：obj.prototype.属性名;3.增加属性：obj.prototype.新属性名 = “xxx”;4.删除属性：通过delete(不能通过对象操作原型) 查看对象的构造函数 constructorconstructor属性是系统给每个对象自带的属性，记录了这个对象的构造函数，可以手动修改 隐式属性__proto__我们之前说，一个对象创建出来，会默认创建一个空对象，但实际上，里边是有系统自带的属性的，当我们找一个对象上的属性不是该对象自身就有的时候，会通过__proto__找到该原型。也可手动修改。123var this = &#123; __proto__:Object.prototype&#125; eg1:1234567Person.prototype.name = &apos;sunny&apos;;function Person()&#123;&#125;var person = new Person();Person.prototype.name=&apos;cherry&apos;console.log(person.name)//结果为cherry,不为sunny,直接操作了属性 eg2:123456789Person.prototype.name = &apos;sunny&apos;;function person()&#123;&#125;var person = new Person();Person.prototype = &#123; name:&apos;cherry&apos;&#125;console.log(person.name)//结果为sunny，不为cherry，已经创建对象之后又修改原型 eg3:123456789Person.prototype.name = &apos;sunny&apos;;function person()&#123;&#125;Person.prototype = &#123; name:&apos;cherry&apos;&#125;var person = new Person();console.log(person.name)//结果为cherry，更改原型之后才创建对象","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"JS对象","slug":"JS对象","date":"2018-07-03T01:23:38.000Z","updated":"2018-07-04T09:34:11.763Z","comments":true,"path":"2018/07/03/JS对象/","link":"","permalink":"http://yoursite.com/2018/07/03/JS对象/","excerpt":"","text":"举例描述我心目中的对象！！(一只狗的独白，委屈巴巴)1234567891011121314151617//咳咳！敲黑板var Boyfriend = &#123; name:&quot;unknow&quot;, age:&quot;unknow&quot;, sex:&quot;male&quot;, height:&quot;180+&quot;, weight:&quot;不胖&quot;, charm:100, basketball:function()&#123; console.log(&quot;我打篮球&quot;); this.charm ++; &#125;, singing:function()&#123; console.log(&quot;我唱歌好听&quot;); this.charm ++; &#125;&#125;//气氛好像有点跑偏 当然啦，此对象非彼对象，就是举个例子，我们继续向下看 对象属性的增、删、改、查1.增加属性：直接 obj.新的属性名 = xxx2.查看属性：obj.属性名(不赋值)3.修改属性：obj.旧属性名 = xxx4.删除属性：delete obj.属性名ps:当一个变量未声明就使用时会报错，但对象的属性未声明就使用则返回undefined 对象的创建方法1.var obj = {} plainObject 对象字面量/对象直接量2.构造函数(1)系统自带构造函数 Object()1var obj = new Object(); 构造函数严格遵守大驼峰式命名方法(2)自定义 构造函数为什么能构造出对象？构造函数内部原理1.在函数体最前面隐式的加上this = {}2.执行 this.xxx = xxx;3.隐式的返回thisps:但凡new出来的对象，返回值必为对象，人为添加原始值不可以 包装类ps:原始值不可以有属性和方法数字(num)、字符串(string)、布尔值(boolean)以上三种数据类型可有两种形式123var num = new number(123);var str = new String(&apos;abcd&apos;);var bol = new Boolean(&apos;true&apos;); 上述形式会将原始值转为对象注意当对象类型的num进行运算后，会变为原始值Q1:既然原始值不能有属性和方法，那么str.length是怎么回事呢？来看一个例子eg1:123456// 包装类var num = 4;num.len = 3;// ****执行过程：new Number(4).len = 3; delete(系统发现原来的是原始值，不可以有属性，所以new一个，尽量满足需求，但num对象上本身没有len属性，则删除new出来的对象，此过程不影响原来的num)****// ****new Number(4).len -&gt;返回undefined，因为Number上并没有自带len属性，但此时的num和上一行的num不同****console.log(num.len) eg2:12345//包装类var str = &quot;1234&quot;;str.length = 2;//****执行过程：new String(&quot;1234&quot;).length = 2; delete****//new String(&quot;1234&quot;).length -&gt; 返回 4 来看一道面试题(记录自己摔的贼惨的深坑)12345678910var str = &quot;abc&quot;;str += 1;var test = typeof(str);//test == &quot;string&quot;if(test.length == 6)&#123; test.sign = &quot;typeof的返回结果可能是String&quot;; //前面不多说，都知道能走进来 //上面那句的test是个原始值啊，原始值啊，原始值啊！哪来的sign啊，当然是下面这样啦！ //new String(test).sign = &apos;xxx&apos;; delete&#125;console.log(test.sign)//new String(test).sign -&gt;打印undefined","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"网络协议(2)","slug":"网络协议-2","date":"2018-06-17T03:18:31.000Z","updated":"2018-06-17T08:42:21.619Z","comments":true,"path":"2018/06/17/网络协议-2/","link":"","permalink":"http://yoursite.com/2018/06/17/网络协议-2/","excerpt":"","text":"IP是怎么来的，又是怎么没的？1.如何配置IP地址 如果有相关的知识的积累，我们就会知道，使用命令行，我们可以手动配置IP地址，使用ipconfig或者ip addr 。那么有一个问题是，自己配置的自由度太大了，难道真的配置什么都可以吗？？？，如果设置一个完全不搭边的地址呢？比如旁边的机器是192.168.1.x,我非要配置16.158.23.6会有什么现象呢？ 答案是不会出现任何现象，只不过是包发布出去，我们举个例子，比如192.168.1.6就在你这台机器的旁边，而你试图把你机器的IP改为16.158.23.6，在这台机器上，你企图去ping192.168.1.6,你是不是认为只要将包发出去，另一台交换机马上就能收到？ 可是linux不是这样的，这里需要了解的一点是，在网络上跑的包，都是完整的，可以有下层没上层，但绝不可以有上层没下层，比如说从上至下是MAC头-&gt;IP头-&gt;TCP头-&gt;HTTP头-&gt;HTTP正文，TCP在三次握手这个活动的时候，IP层和MAC层也都会随着TCP层一起活动。因为，TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。所以，你看着它好像是有自己的IP地址，但是包发不出去，因为此时MAC层还没填。 自己的MAC地址自己知道，但目标的MAC填什么呢？是不是填192.168.1.6这台机器的MAC地址呢？当然不是的，linux首先会判断，要去的这个地址和我是一个网段的吗？只有是一个网段的时候，才会发送ARP请求获取MAC地址，如果不是一个网段的，它会试图将包发到网关。 如果你配置了网关，linux会去获取网关的MAC地址，然后将包发送出去，如果没配置网关，那么这个包是根本发送不出去的，如果把网关配置为192.168.1.6是不是就可以呢？当然不可能，因为网关要和当前的网络至少一个网卡是同一网段的，所以当你需要手动配置一台机器的网络IP时，一定要好好问问你的网络管理员，最好去网络管理员处申请，让他分配一段正确的IP，当然了，真正配置的时候不是用命令配置的，而是放在一个配置文件中，包含CIDR、子网掩码、广播地址和网关地址 2.动态主机配置协议(DHCP) 配置了IP一般是不变的，配置一个服务器端的机器还可以，但是如果客户端的机器怎么办呢？总不能随来随配吧，因此我们有了一个自动配置的协议，也称动态主机配置协议(Dynamic Host Configuration Protocol)，简称DHCP 有了这个协议，管理员只需配置一段共享的IP地址，每一台新接入的机器都通过DHCP协议来这个共享的IP地址中申请，然后自动配置好，用完以后再还回去，方便其他机器接入使用 3.了解DHCP的工作方式 当一台机器新加入一个网络的时候，一脸懵逼，只知道自己的MAC地址，先大吼一声“我来啦！”这一步，我们称为DHCP Discover。 新来的机器使用IP地址0.0.0.0发送了一个广播包，目标地址IP为255.255.255.255，广播包封装在UDP中，UDP封装在BOOTP里边，在这个广播包里边，新人喊“我是新来的(Boot request),我的MAC地址是这个，还没有IP呢，谁能给我一段IP？？？” 如果一个管理员在网络中配置了DHCP Server的话，他就相当于这些IP的管理员。他能立刻知道来了一个新人，这个时候，我们就知道MAC地址唯一的重要性了，当一台机器带着自己的MAC地址加入一个网络的时候，MAC是他惟一的身份表示，如果连这个都重复了，那也就没办法配置了 只有MAC唯一，IP管理员才知道这是一个新人，需要租给他一个IP，这个过程，我们称为DHCP Offer同时，DHCP Server为该用户保留为他提供的IP地址，从而不会为其他的DHCP客户分配此地址，但此时此刻DHCP Server仍然使用广播的地址作为目标地址，DHCP Server回复说“我分配了一段IP地址，你看看怎么样”除此之外，服务器还会发送子网掩码、网关和IP地址租用期等信息。新机器会选择一个IP，然后向网络发送一个DHCP Request广播数据包，包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等，它会告诉所有DHCP Server他将接受那一台服务器提供的IP地址，告诉其他DHCP Server谢谢你们并请求撤回他们提供的IP地址注意由于此时还未收到服务器端回应，所以此时的IP仍然是0.0.0.0，目标地址仍然是255.255.255.255 服务器收到客户机的DHCP Request之后，会返回给客户机一个ACK包，表示接受客户机选择，并将这一IP地址合法租用信息和其他租用信息放入广播包，发送给客户机，最终租约达成的时候还要广播一下，让大家都知道。","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"Jquery回顾(1)","slug":"Jquery回顾-1","date":"2018-06-11T07:08:13.000Z","updated":"2018-06-11T09:00:33.445Z","comments":true,"path":"2018/06/11/Jquery回顾-1/","link":"","permalink":"http://yoursite.com/2018/06/11/Jquery回顾-1/","excerpt":"","text":"1.循环遍历：123$(&apos;obj&apos;).each(function(index,ele)&#123; //函数体&#125;) 有趣的是js中的循环遍历方法比如forEach()的参数为① ele ② index，而jq中循环遍历方法比如each()、filter()、not()的参数为① index ② ele 刚好调换 2.添加css样式1$(&apos;obj&apos;).css(&#123;background:green;border:1px solid #000;&#125;) 或1$(&apos;obj&apos;).css(&apos;color&apos;,&apos;red&apos;) 3.选择元素(1)$()里面和css选择一样，注意对选择出的一组元素，一起处理，省略循环，这里在js中是不允许的(2)里面可以写css选择器、$、原生dom、jquery对象、null/undefined、函数function(){}、selector/content等(3)jquery特有选择规则(选择出来的是jquery对象)eg:1234$(&apos;ul&gt;li:first&apos;);$(&apos;ul&gt;li:eq(2)&apos;);$(&apos;ul&gt;li:odd/even&apos;);//odd是奇数，even是偶数//也可以写成$(&apos;ul&gt;li&apos;).first()其他相同 (4)filter筛选eg:12345$(&apos;li&apos;).filter(function(index)&#123; return index%2 == 0; &#125;).css(&apos;background&apos;,red); //筛选下标为偶数的li设置背景颜色为红色 (5)not筛选：语法与filter完全相同，但筛选规则完全相反，即筛选不满足条件的(6)has筛选:找有某项子级的父元素，不一定是直接子元素，有就行eg:1$(&apos;li&apos;).has(&apos;span&apos;).css(&apos;color&apos;,&apos;red&apos;); //这里筛选的是子级有span标签的&lt;li&gt;标签，注意是&lt;li&gt;标签 (7)find筛选：被找到的元素本身eg:1$(&apos;li&apos;).find(&apos;span&apos;).css(&apos;color&apos;,&apos;red&apos;); (8)eq筛选：选择具体下标的元素(9)is筛选：是就返回true，不是返回falseeg:1$(&apos;li&apos;).eq(4).is(&apos;.demo&apos;);//判断下标是4的li是不是class为demo的 D1:对于selector/content的解释eg:1$(&apos;span&apos;,&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;) 目的在于选择span，什么样的span呢？在div这个上下文之内的span都可以 D2:对于函数function的解释123$(function()&#123; console.log(666); &#125;) 上面的代码会立刻执行打印到控制台 D2.Q1：提出一个问题，以下代码的执行顺序是什么，为什么eg1:12345678window.onload = function()&#123; console.log(777)&#125;$(function()&#123; console.log(666); &#125;) //答案：先输出777，再输出666，难道是因为777写在上面了？我们继续看 eg2:12345678$(function()&#123; console.log(666); &#125;)window.onload = function()&#123; console.log(777)&#125;//答案：仍然先输出777，再输出666 D2.A1:新版本的jquery将$()中的函数的执行顺序调整到window.onload之后执行了，$(function(){})中调用了jq自己定义的ready方法，以下两种方法没有区别，谁写在上边谁先执行，但都在window.onload之后1234567$().ready(function()&#123; console.log(888) &#125;)$(function()&#123; console.log(666) &#125;) //先输出888，再输出666，若调换顺序，则先输出666，再输出888 4.jQuery函数写法当js和jq同时使用时需注意，只有js对象可以调用js方法，只有jq对象可以调用jq方法，交叉调用是不可以的，因此有些时候需要将js对象转变为jq对象，有时候也需要将jq对象转变为js对象 [1]jquery dom元素方法——get()方法：将jq对象转变为js对象，返回dom1$(selector).get(index) [2].取值赋值函数统一性html();text();css();attr();prop();以上函数如果传值，即为赋值，若不传值，即为取值css()取值相当于getComputed,赋值相当于dom.style.xxx，css()赋值赋一组，取值取一个(第一个 颜色会在内部转换成rgb) attr()函数主要依赖的是Element对象中getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是js原生对象属性获取和设置方式jQuery认为：attribute的checked、selected、disabled就是表示该属性初始状态的值，property的checked、selected、disabled才表示该属性实时状态的值(true/false) [3].dom操作(1)$(obj).next()下一个兄弟节点(2)$(obj).prev()上一个兄弟节点(3)$(obj).index()当前这个节点在兄弟节点中的索引(若之前返回的对象是一组数据则从第一个开始返回) ps:Jquery之所以可以链式调用，是因为每次执行都返回了相应的对象","categories":[],"tags":[{"name":"温故知新","slug":"温故知新","permalink":"http://yoursite.com/tags/温故知新/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"网络协议(1)","slug":"网络协议-1","date":"2018-06-09T06:40:34.000Z","updated":"2018-06-10T05:33:21.559Z","comments":true,"path":"2018/06/09/网络协议-1/","link":"","permalink":"http://yoursite.com/2018/06/09/网络协议-1/","excerpt":"","text":"最近阅读了几篇不错的文章，谈一谈自己的感想，仅代表个人观点，若有不对的地方，欢迎各位指正 首先抛出一个问题，网络协议是什么？ 我们都知道，计算机很聪明，聪明到知道海量的知识，但同时它又很笨，笨到只认识0和1，我们人类要想与计算机沟通，需要一段文字把我们与计算机紧密结合起来，这段文字就是一种协议，只有通过这种协议，计算机才知道我们想让它做什么 1.协议三要素 1.语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。2.语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。3.顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值 当然了，只有一台电脑是完全不能满足我们平时的网络活动的，这时就需要一大片机器协同完成一件事，而只其中必不可缺的一项就是网络协议 2.简述网络协议 文章中用了一个购物网站下单的例子来展开，我们也就借花献佛，以此来引出我们的主题 当我们想要购买一件商品的时候，一般都会打开浏览器，输入购物地址，紧接着，浏览器就给你返回了一个绚丽多彩的页面了。那么问题来了，，，你有没有考虑过浏览器是怎样实现这一过程的呢？ 首先在浏览器中输入https://www.xxx.com ，这是一个url，浏览器会通过地址簿协议DNS或者HTTPDNS去查找，无论用哪种方式查找，最终会得到一个地址，比如我们黑龙江大学校园网125.223.1.123，这是一个IP地址，就像是我们家里的门牌号。 知道了目标地址之后，浏览器将请求打包，对于普通的网络请求，会使用HTTP协议，如果是购物，那么它涉及到你个人的私密信息，所以一般用HTTPS协议加密传输，说到这里，我们提到的DNS，HTTP，HTTPS协议都已经开始发挥了作用，他们所发挥作用的这一层是我们网络模型的第一层——应用层 经过了应用层的封装，浏览器将应用层的包发送给下一层去完成，接下来的一层叫做传输层，有两种协议，①无连接的UDP协议②面向连接的TCP协议，无连接的意思是，我只负责把上一层的包发出去，至于发送成没成功我就不管了。而面向连接的意思是，包一旦发出我会看着它，一遍没发送成功，我就继续发送，直到发送成功为止（ps:TCP协议不会引起多次请求，不管TCP发送多少次都发生在一次请求过程之内） TCP协议中有两个端口，一个是浏览器监听的端口，一个是目标服务器的端口，当传输层封装完毕后，浏览器会将包发送到下一层，即网络层。网络层的协议是IP协议，IP协议中会有两个IP地址，即浏览器所在主机的IP地址和目标服务器所在主机的IP地址。这个时候可以说已经获取了明确的地址了。 这个时候，问题又来了，我们知道门牌号了，我们怎么去嘞？？？ 这个时候操作系统要进行判断了，如果这个地址在本地，那么好，直接靠吼，一吼“谁是125.223.1.123啊？”，黑大网关回应：“我再这旮沓呢！！！”，这一吼，调用了ARP协议。如果这个地址不在本地可咋整呢？就好比我有一个朋友，家在美国，那我想从中国要去他家，我必须得通过美国海关对吧。网络也是一样，到外地去，也要通过各种关卡，这种关卡就是网关，网关所拥有的mac地址是独一无二的。这个时候操作系统就把IP包交给下一层了，也就是mac层。网关收到包之后，会根据路由表判断下一步往哪里走，每一个网关都像是唐僧西天取经路上的一个国家，每一个国家是一片局域网，出了这片局域网，就得使用IP头来进行确认下一步要往哪走，知道走到最后一个城关，在本地一吼，找到对应的mac地址，网络包过了这道城关，最终找到目标服务器。 目标服务器发现，mac地址对上了，取下mac头发送回网络层，网络层发现IP也对上号了，取下IP头，IP头中会封装TCP协议，然后传给传输层，传输层中会收到前面几层收到包的回复，这些回复也会原路返回报个平安。最终回到应用层把携带的html/css页面展现到浏览器上。","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"JS函数","slug":"JS函数","date":"2018-06-07T05:28:19.000Z","updated":"2018-07-04T09:34:39.219Z","comments":true,"path":"2018/06/07/JS函数/","link":"","permalink":"http://yoursite.com/2018/06/07/JS函数/","excerpt":"","text":"1.匿名函数：不能单独写在页面内作用：赋值，传参(匿名函数可作为参数) 2.有名函数:在function后加名字(1)可加括号自执行(2)可把名字直接放在事件位置 例： 1234function a()&#123; alert(666); &#125; document.onclick = a; 回顾：数据类型：num String boolean null undefined objecttypeof:把null归为object,增加function函数表达式和函数定义的区别：函数表达式可直接加括号自执行；123例：var a = function()&#123; alert(1); &#125;();//可执行 将匿名函数强转为函数表达式的方法：在前面加 位操作符(~ + - !)或(function(){……});函数参数：1.形参2.实参ps:实参多于形参时，多出部分相当于没有，实参少于形参时，未接收到数据的形参为undefined 关于null和undefinednull指向一个空的对象地址，因此typeof将null归为object 123456if(null==undefined)&#123; alert(1); &#125; else&#123; alert(0); &#125;//弹出1，在逻辑运算中null和undefined相等，但不全等，原因就是他们是两种不同的数据类型 undefined 不报错 声明但未定义is not defined 报错，未声明 3.不定参:arguments代表不定参数的集合12345678例：function fn()&#123; var sum=0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum+=arguments[i] &#125; alert(sum); &#125; fn(1,2,3,4,5);//弹出15 JS代码解析：第一步，解析定义，包括变量定义和函数定义，普通变量重名，后者覆盖前者。但若定义函数名和普通变量重名，函数优先级大于普通变量(var)第二步，解析执行，除定义之外的部分，包括赋值，运算等等123function A()&#123; alert(0);&#125;//从上至下，先看定义，定义了函数A，再执行，执行后弹出0 1var a = 10; //从上至下，先看定义，此时a=10,再看执行，由于alert括号内重新声明了a,所以此时a变为undefined。但若把下面的var去掉，由于少了var这一环节，所以程序报错","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-05T05:19:37.036Z","updated":"2018-06-07T04:21:10.202Z","comments":true,"path":"2018/06/05/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/05/hello-world/","excerpt":"","text":"这个博客用来记录我个人的学习和生活，欢迎各位指点交流！","categories":[],"tags":[]}]}